<?php
/**
 * @file stanford_sws.module
 *
 * @author (s)
 *         Shea McKinney / sherakama
 *
 * @description
 * This module provides helper functionality to the sws site within a site
 * feature.
 *
 *
 * @todo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *
 *
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *
 */


// The content type that defines a subsite
DEFINE('SUBSITE_CONTENT_TYPE', "sub_site");
// The reference field that connects a child node to a subsite
DEFINE('SUBSITE_REF_FIELD', 'field_sws_sub_site');
// The field that changes the site title
DEFINE("SUBSITE_NAME_FIELD", "field_sws_site_name");
// The field that changes the site logo
DEFINE("SUBSITE_LOGO_FIELD", "field_sws_site_logo");
// The field that changes $front_page
DEFINE("SUBSITE_FRONT_PAGE_FIELD", "field_sws_front_page");
// The field that changes the theme and sets the themekey settings
DEFINE("SUBSITE_THEME_FIELD", "field_sws_site_theme");
// The subsite vocabulary machine name
DEFINE("SUBSITE_VOCAB", "sws_sub_sites");
// The subsite tags field
DEFINE("SUBSITE_TAGS_FIELD", "field_sws_subsite_tags");


/**
 * Implements hook_help().
 */
function stanford_sws_help($path, $arg) {
  switch ($path) {
    // Main module help for the block module
    /*
     *case 'admin/help#block':
     *  return '<p>' . t('Blocks are boxes of content rendered into an area, or region, of a web page. The default theme Bartik, for example, implements the regions "Sidebar first", "Sidebar second", "Featured", "Content", "Header", "Footer", etc., and a block may appear in any one of these areas. The <a href="@blocks">blocks administration page</a> provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions.', array('@blocks' => url('admin/structure/block'))) . '</p>';
     */
    case 'admin/help#sws':
      return '<p>' . t('For more help please contact stanford web services: %email',
       array('%email' => 'help@stanford.edu')) . '</p>';
  }
  return;
}

/**
 * Implements hook_permission().
 */
function stanford_sws_permission() {
  return array(
    'administer sws' => array(
      'title' => t('Administer SWS'),
      'description' => t('Perform administration tasks for site within a site.'),
    ),
    'administer subsite selection' => array(
      'title' => t('Administer Subsite Selection'),
      'description' => t('Access and change the subsite selection field'),
    ),
  );
}

/**
 * Implements hook_custom_theme().
 */
function stanford_sws_custom_theme() {

  /*
    Check to see if this page is a node. If so apply subtheme by node reference
   */
  $a0 = arg(0);
  $a1 = arg(1);
  $subsite_node = FALSE;

  if($a0 == "node" && is_numeric($a1)) {
    $node = node_load($a1);
    $subsite_node = _lookup_subsite_reference_by_node($node);
  }

 /*
    If the page being viewed is not a node then check the path
  */

  if(!$subsite_node) {
    $request_path = request_path();
    $subsite_node = _lookup_subsite_reference_by_path($request_path);
  }

  // Apply the field values

  if(isset($subsite_node->{SUBSITE_THEME_FIELD}[$subsite_node->language][0]['value'])
    && $subsite_node->{SUBSITE_THEME_FIELD}[$subsite_node->language][0]['value'] !== "default") {
    return $subsite_node->{SUBSITE_THEME_FIELD}[$subsite_node->language][0]['value'];
  }

}


/**
 * Implements hook_preprocess().
 */
function stanford_sws_preprocess_page(&$variables, $hook) {

  /*
    Check to see if this page is a node. If so apply subtheme by node reference
   */
  if(isset($variables['node'])) {
    $node = $variables['node'];

    if($subsite_node = _lookup_subsite_reference_by_node($node)) {
        stanford_sws_apply_subsite($subsite_node, $variables);
    }

    return;
  } // end if node//

  /*
    If the page being viewed is not a node then check the path
  */

  $request_path = request_path();
  $subsite_node = _lookup_subsite_reference_by_path($request_path);

  if($subsite_node) {
    stanford_sws_apply_subsite($subsite_node, $variables);
  }

}

/**
 * stanford_sws_apply_subsite
 * @param $node - the subsite node object
 * @param $variables - The variables array from hook_preprocess_page
 * Function tasks:
 *   1. Change $title [if set]
 *   2. Change $logo [if set]
 *   3. Change the $front_page url [if set]
 */

function stanford_sws_apply_subsite($node, &$vars) {

  // Change the site Title
  if(isset($node->{SUBSITE_NAME_FIELD}[$node->language][0]["safe_value"])
    && !empty($node->{SUBSITE_NAME_FIELD}[$node->language][0]["safe_value"]))
  {
    $vars['site_name'] = $node->{SUBSITE_NAME_FIELD}[$node->language][0]["safe_value"];
  }

  // Change the site logo
  if(isset($node->{SUBSITE_LOGO_FIELD}[$node->language][0]["uri"])
    && !empty($node->{SUBSITE_LOGO_FIELD}[$node->language][0]["uri"]))
  {
    $vars['logo'] = file_create_url($node->{SUBSITE_LOGO_FIELD}[$node->language][0]["uri"]);
  }

  // Change $front_page url
  if(isset($node->{SUBSITE_FRONT_PAGE_FIELD}[$node->language][0]["value"])
    && $node->{SUBSITE_FRONT_PAGE_FIELD}[$node->language][0]["value"])
  {
    $vars['front_page'] = url('node/' . $node->nid, array('absolute' => TRUE));
  }

}

/**
 * Implements hook_node_submit().
 * @param $node: The node object being updated in response to a form submission.
 * @param $form: The form being used to edit the node.
 * @param $form_state: The form state array.
 *
 * Utiltity tasks for saving nodes of various types
 * 1. Clear path caches for sub_sites
 * 2. Check for missing subsite field on non sub_site nodes
 */
function stanford_sws_node_submit($node, $form, &$form_state) {

  // If we are saveing a sub_site content type clear path cache
  // and perform sub_site specific handling
  if($node->type == SUBSITE_CONTENT_TYPE) {
    // Clear all path caches
    cache_clear_all('stanford_sws_subsite_paths', 'cache', TRUE);
  }


  // If the user did not have access to the subsite selector then we need to add
  // the users subsite setting to the node
  global $user;
  $account = user_load($user->uid);
  $values = &$form_state['values'];
  $language = $form['language']['#value'];

  // Check to see if the reference field is in the form and if it was submitted
  if(isset($form[SUBSITE_REF_FIELD]) && !isset($values[SUBSITE_REF_FIELD])) {
    // Field exists on this form but was not submitted. User did not have access

    if(isset($account->{SUBSITE_REF_FIELD}[$language][0]['target_id']) &&
      is_numeric($account->{SUBSITE_REF_FIELD}[$language][0]['target_id']))
    {
      // User has a subsite setting
      $ref_id = $account->{SUBSITE_REF_FIELD}[$language][0]['target_id'];
      form_set_value($form[SUBSITE_REF_FIELD], $ref_id, $form_state);
      $node->{SUBSITE_REF_FIELD}[$language][0]['target_id'] = $ref_id;
    }

  }

  // Check to see if the submitted node has a subsite_tags field and a reference
  // the the subsite that is selected in the ref field
  if(isset($form[SUBSITE_TAGS_FIELD])) {

    // Check to see that there is a subsite NID available
    if(isset($values[SUBSITE_REF_FIELD][$language][0]['target_id'])
      && is_numeric($values[SUBSITE_REF_FIELD][$language][0]['target_id']))
    {

      $subsite_node = node_load($values[SUBSITE_REF_FIELD][$language][0]['target_id']);
      $subsite_term = _get_subsite_term($subsite_node);
      $found_term = FALSE; // boolean switch for finding the term

      // check to see that tags field has reference
      foreach($values[SUBSITE_TAGS_FIELD][$language] as $k => $term) {
        if($term['tid'] == $subsite_term->tid) {
          $found_term = TRUE;
          break;
        }
      }

      // Did not find the subsite term in the subsite tags field. Add it!
      if(!$found_term) {
        $tags = $values[SUBSITE_TAGS_FIELD][$language];
        $tags[] = (array)$subsite_term;
        form_set_value($form[SUBSITE_TAGS_FIELD], $tags, $form_state);
        $node->{SUBSITE_TAGS_FIELD}[$language] = $tags;
      }

    }

  }

}

/**
 * Handles the insert of a new sub_site content type
 * @param  object $node       the node object
 *
 * Tasks:
 * 1. Create subsite term
 */
function stanford_sws_node_insert($node) {

  // We have a new sub_site content type. Lets add it to the sub_site vocabulary
  if($node->type == SUBSITE_CONTENT_TYPE) {
    _insert_subsite_term($node);
  }

  // automatically tag content with subsite term on creation


}


/**
 * Implements hook_node_update().
 */
function stanford_sws_node_update($node) {
  // Clear out all of the subsite paths
  if($node->type == SUBSITE_CONTENT_TYPE) {
    // Clear all path caches
    cache_clear_all('stanford_sws_subsite_paths', 'cache', TRUE);
    _update_subsite_node_term_name($node);
  }

}


/**
 * Implements pathauto_alias_alter()
 * Prepends the pathalias of the subsite to a node being referenced to one
 */
function stanford_sws_pathauto_alias_alter(&$alias, $context) {
  $node = $context['data']['node'];

  // If there is a reference to a sub site then alter the pathauto_alias
  if(isset($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']) ||
  is_object($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']))
  {
    $subsite_node = node_load($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']);
    $alias = drupal_get_path_alias("node/" . $subsite_node->nid) . "/" . $alias;
  }

}

/**
 * Implements hook_form_alter().
 * Add the active theme options to the theme field
 */
function stanford_sws_form_node_form_alter(&$form, &$form_state, $form_id) {

  if($form_id == SUBSITE_CONTENT_TYPE . "_node_form") {
    stanford_sws_form_node_form_alter_subsite_node($form, $form_state, $form_id);
    return;
  }

  // The node form..
  $language = $form['language']['#value'];
  // global user object
  global $user;
  $account = user_load($user->uid);


  // Check for site theme field
  if(isset($form[SUBSITE_REF_FIELD])) {

    // If default subsite is not selected then set to users account setting
    if(empty($form[SUBSITE_REF_FIELD][$language]['#default_value'][0]) ||
      !is_numeric($form[SUBSITE_REF_FIELD][$language]['#default_value'][0]))
    {
      // Check to see if the user has a subsite account setting
      if(isset($account->{SUBSITE_REF_FIELD}[$language][0]['target_id']) &&
        is_numeric($account->{SUBSITE_REF_FIELD}[$language][0]['target_id']))
      {
        $form[SUBSITE_REF_FIELD][$language]['#default_value'][0] = $account->{SUBSITE_REF_FIELD}[$language][0]['target_id'];
      }

    }

  }


}

/**
 * stanford_sws_form_node_form_alter_subsite_node()
 * @param   $form the form array
 * @param   $form_state the submitted form state
 * @param   $form_id the form id
 *
 */
function stanford_sws_form_node_form_alter_subsite_node(&$form, &$form_state, $form_id) {
  $node = $form['#node'];

  $themes = list_themes();
  foreach($themes as $k => $theme) {
    $form[SUBSITE_THEME_FIELD][$node->language]['#options'][$k] = $k;
  }

  $form[SUBSITE_THEME_FIELD][$node->language]['#default_value'] =
    (isset($node->{SUBSITE_THEME_FIELD}[$node->language][0]['value']))
    ? $node->{SUBSITE_THEME_FIELD}[$node->language][0]['value']
    : "default";
}


/**
 * Implements hook_field_access().
 */
function stanford_sws_field_access($op, $field, $entity_type, $entity, $account) {

  // check to see if user can edit the subsite selection field
   if ($field['field_name'] == SUBSITE_REF_FIELD && $op == 'edit') {
     return user_access('administer subsite selection', $account);
   }

  return TRUE;
}



//  ////////////////////////////////////////////////////////////////////////////
//  HELPERS //
//  ////////////////////////////////////////////////////////////////////////////

/**
 * _lookup_subsite_reference_by_node()
 * @param $node - The currently being viewed node object
 * @return  boolen - True if this node has a subsite / False if none
 */

function _lookup_subsite_reference_by_node($node) {

  // If the node that is being viewed is the subsite node then just return it!
  if($node->type == SUBSITE_CONTENT_TYPE) { return $node; }

  // Node is of another type... Get parent
  if(!isset($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']) ||
  !is_numeric($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']))
  {
    return false;
  } // no reference

  // This should always be a subsite content type based on field settings
  $subsite_node = node_load($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']);

  // But just in case someone mucked with them
  if($subsite_node->type !== SUBSITE_CONTENT_TYPE) {
    return false;
  }

  return $subsite_node;
}

/**
 * _lookup_subsite_reference_by_path
 * @param  $path - String - The currently viewed url path
 * @return Mixed - A node object of the subsite node or false if none
 */

function _lookup_subsite_reference_by_path($path) {

  // First get all of the sub site paths
  $subsite_paths = _get_subsite_paths();

  // Check raw string for path... :( needs optimization
  foreach($subsite_paths as $nid => $site_path) {
    if(stripos($path, $site_path) !== FALSE) {
      return node_load($nid);
    }
  }

  return FALSE;
}

/**
 *_get_subsite_paths
 * @return  Array | an array of subsite paths
 */
function _get_subsite_paths() {

  $paths = cache_get('stanford_sws_subsite_paths');

  // If cache isnt set then we need to generate it
  if(!$paths) {
    $paths = array();
    $query = db_select('node','n')
              ->fields('n', array('nid'))
              ->condition('type', SUBSITE_CONTENT_TYPE)
              ->execute();

    while($path_string = $query->fetchAssoc()) {
      $paths[$path_string['nid']] = drupal_get_path_alias("node/" . $path_string['nid']);
    }
    cache_set('stanford_sws_subsite_paths', $paths);
    return $paths;
  }

  // Cached version
  return $paths->data;
}

/**
 * Generate a term for the subsite vocabulary
 * @param  object $node the subsite node
 * @return Object   the new term object or false if failed
 */
function _insert_subsite_term($node) {
  $term = new stdClass();
  $term->name = $node->title;
  $term->description = "Vocabulary term for " . $node->{SUBSITE_NAME_FIELD}[$node->language][0]['value'] .  " subsite";
  $term->vocabulary_machine_name = SUBSITE_VOCAB;
  $term->format = "filtered_html";

  $vocabulary = taxonomy_vocabulary_machine_name_load(SUBSITE_VOCAB);
  $term->vid = $vocabulary->vid;


  $status = taxonomy_term_save($term, SUBSITE_VOCAB);
  if($status) {
    return $term;
  }
  else {
    drupal_set_message("FAILED TO INSERT NEW SUBSITE TERM", 'error');
  }

}

/**
 * Looks to update the term name in the subsite vocabulary if the node title
 * Changes on update
 * @param  object $node The original Node Object
 */
function _update_subsite_node_term_name($node) {

  // New node has been saved but we can still get the old node from cache
  $old_node = node_load($node->nid);

  // Check if the title of the node changed
  if($old_node->title == $node->title) {
    return; // they are the same. Nothing to do here.
  }

  // The title is different. Load up term by term name
  $terms = taxonomy_get_term_by_name($old_node->title, SUBSITE_VOCAB);

  // Failed to get a term. Lets insert a new one
  if(!$terms) {
    $term = _insert_subsite_term($node);
    return;
  }

  // Change the name and save it
  $old_term = array_pop($terms);
  $term = clone($old_term);
  $term->name = $node->title;
  $term->original = $old_term;

  $term = taxonomy_term_save($term, SUBSITE_VOCAB);
  return $term;
}

/**
 * Returns the term object associated with a subsite node
 * @param  $node  The subsite node object
 * @return  object | The term object or false
 */
function _get_subsite_term($node) {

  // The title is different. Load up term by term name
  $terms = taxonomy_get_term_by_name($node->title, SUBSITE_VOCAB);

  // Failed to get a term. Lets insert a new one
  if(!$terms) {
    return FALSE;
  }

  return array_pop($terms);
}

