<?php
/**
 * @file
 * stanford_subsites.module
 *
 * @author (s)
 *         Shea McKinney / sherakama
 *
 * @description
 * This module provides helper functionality to the sws site within a site
 * feature.
 *
 *
 * @todo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *  remove all 'Features' and have this whole thing as one module using
 *  field api more.
 *
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 */


// The content type that defines a subsite.
define('SUBSITE_CONTENT_TYPE', "stanford_subsite");
// The reference field that connects a child node to a subsite.
define('SUBSITE_REF_FIELD', 'field_stanford_subsite_subsite');
// The reference field that connects a user to a subsite.
define('SUBSITE_USER_REF_FIELD', 'field_stanford_subsite_usr_sub');
// The field that changes the site title.
define("SUBSITE_NAME_FIELD", "field_stanford_subsite_sname");
// The field that changes the site slogan.
define("SUBSITE_SLOGAN_FIELD", "field_stanford_subsite_slogan");
// The field that changes the site logo.
define("SUBSITE_LOGO_FIELD", "field_stanford_subsite_logo");
// The field that changes $front_page.
define("SUBSITE_FRONT_PAGE_FIELD", "field_stanford_subsite_front");
// The field that changes the theme.
define("SUBSITE_THEME_FIELD", "field_stanford_subsite_theme");
// The subsite vocabulary machine name.
define("SUBSITE_VOCAB", "stanford_subsites_sites");
// The subsite tags field.
define("SUBSITE_TAGS_FIELD", "field_stanford_subsite_sub_tags");


// Global variable for active subsite.
global $subsite;

// Load helper files.
module_load_include('inc', 'stanford_subsites', 'stanford_subsites');


/**
 * Implements hook_help().
 *
 * @param string $path
 *    path to help page
 * @param array $arg
 *    args
 * @return array
 */
function stanford_subsites_help($path, $arg) {
  switch ($path) {
    case 'admin/help#sws':
      return '<p>' . t('For more help please contact stanford web services: %email',
       array('%email' => 'help@stanford.edu')) . '</p>';
  }
  return;
}

/**
 * Implements hook_menu().
 */
function stanford_subsites_menu() {
  $items = array();

  $items['admin/config/subsites'] = array(
    'title' => 'Stanford Subsite Settings',
    'description' => 'Settings and configuration options for site within a site behavior',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('stanford_subsites_admin_config_form'),
    'file' => 'stanford_subsites.admin.inc',
    'access arguments' => array('administer sws'),
  );

  return $items;
}

/**
 * Implements hook_menu_alter
 * @param  $menu [description]
 */
function stanford_subsites_menu_alter(&$menu) {
  $menu['entityreference/autocomplete/single/%/%/%']['page callback'] = "stanford_subsites_entityreference_autocomplete_callback";
}


/**
 * Implements hook_init().
 */
function stanford_subsites_init() {
  // Set the global $subsite var for use elsewhere.
  _get_active_subsite();
}


/**
 * Implements hook_permission().
 */
function stanford_subsites_permission() {
  return array(
    'administer sws' => array(
      'title' => t('Administer Stanford Subsite'),
      'description' => t('Perform administration tasks for site within a site.'),
    ),
    'administer subsite selection' => array(
      'title' => t('Administer Subsite Selection'),
      'description' => t('Access and change the subsite selection field'),
    ),
  );
}

/**
 * Implements hook_custom_theme().
 */
function stanford_subsites_custom_theme() {

  // Check to see if this page is a node. If so apply subtheme by node reference.
  $subsite_node = _get_active_subsite();

  // Apply the field values.
  if ($subsite_node &&
    isset($subsite_node->{SUBSITE_THEME_FIELD}[$subsite_node->language][0]['value'])
    && $subsite_node->{SUBSITE_THEME_FIELD}[$subsite_node->language][0]['value'] !== "default") {
    return $subsite_node->{SUBSITE_THEME_FIELD}[$subsite_node->language][0]['value'];
  }

}


/**
 * Add some additional variables to the preprocess page function for use in the
 * theme templates like
 *   $vars['site_name'];
 * @param $vars
 *        An array or variables
 * @param  $hook
 *         A string of the hook name
 */

function stanford_subsites_preprocess_html(&$vars, $hook) {

  $vars['site_name'] = variable_get('site_name');
  $vars['subsite_site_name_text'] = FALSE;
  $vars['subsite_site_name_html'] = FALSE;

  // Check to see if this page is a node. If so apply subtheme by node reference.
  $subsite_node = _get_active_subsite();

  if ($subsite_node) {
    $vars['subsite_site_name_text'] = $subsite_node->{SUBSITE_NAME_FIELD}[$subsite_node->language][0]["safe_value"];
    $vars['subsite_site_name_html'] = l($vars['subsite_site_name_text'], "<front>");
  }
  else {
    $vars['subsite_site_name_html'] = l($vars['site_name'], "<front>");
  }

}



/**
 * Implements hook_preprocess().
 * [stanford_subsites_preprocess_page description]
 * @param  [type] $vars [description]
 * @param  [type] $hook [description]
 *
 */
function stanford_subsites_preprocess_page(&$vars, $hook) {

  // Some variables need to be persistent
  $vars['subsite_logo_html'] = FALSE; // the subsite logo full html and link
  $vars['subsite_site_name_html'] = FALSE; // the subsite name full html and link
  $vars['subsite_site_name_text'] = FALSE; // the subsite name plain text
  $vars['subsite_name_logo_setting'] = "default";
  $vars['alt'] = $vars['site_name']; // the alt text for the logo image
  $vars['logo_title'] = $vars['site_name']; // The title text for the logo image
  $vars['subsite_is_front'] = FALSE; // boolean value if current type is subsite
  $vars['subsite_front'] = FALSE; // string of the path to the active subsite

  // Check to see if this page is a subsite node type. If it is then we are at
  // a subsite 'front'
  if (isset($vars['node']) && $vars['node']->type == SUBSITE_CONTENT_TYPE) {
    $vars['subsite_is_front'] = TRUE;
  }

  // Apply the subsite.
  $subsite_node = _get_active_subsite();

  if ($subsite_node) {
    stanford_subsites_apply_subsite($subsite_node, $vars);
  }
  else {
    if ($vars['logo']) {
      $img = theme("image",
        array(
          'path' => $vars['logo'],
          'role' => 'presentation',
          'alt' => check_plain($vars['alt']),
          'title' => check_plain($vars['site_name']),
          'attributes' => array(
            'class' => 'subsite-logo',
          ),
        )
      );
      $vars['subsite_logo_html'] = l($img, "<front>", array('html' => TRUE));
    }
    $vars['subsite_site_name_html'] = l($vars['site_name'], "<front>");
  }
  // End else if subsite.

}

/**
 * stanford_subsites_apply_subsite
 * @param $node - the subsite node object
 * @param $variables - The variables array from hook_preprocess_page
 * Function tasks:
 *   1. Change $title [if set]
 *   2. Change $logo [if set]
 *   3. Change the $front_page url [if set]
 *   4. Create new $logo_title & $alt template variables
 *   5. Create completely new $subsite_logo and $subsite_title
 *      variables with links
 *   6. Override the site_logo variable with subsite logo if present.
 */

function stanford_subsites_apply_subsite($node, &$vars) {

  // Change the site title.
  if (isset($node->{SUBSITE_NAME_FIELD}[$node->language][0]["safe_value"])
    && !empty($node->{SUBSITE_NAME_FIELD}[$node->language][0]["safe_value"])) {
    $vars['site_name'] = $node->{SUBSITE_NAME_FIELD}[$node->language][0]["safe_value"];
    $vars['subsite_site_name_text'] = $vars['site_name'];
  }



  // Create new $logo_title and $alt variables for use in the page.tpl.php
  $vars['alt'] = $vars['site_name'];
  $vars['logo_title'] = $vars['site_name'];

  // Change the site logo.
  if (isset($node->{SUBSITE_LOGO_FIELD}[$node->language][0]["uri"])
    && !empty($node->{SUBSITE_LOGO_FIELD}[$node->language][0]["uri"])) {
    $vars['logo'] = file_create_url($node->{SUBSITE_LOGO_FIELD}[$node->language][0]["uri"]);

    // Check for alt and title information on the image field.
    if (isset($node->{SUBSITE_LOGO_FIELD}[$node->language][0]['alt']) &&
      !empty($node->{SUBSITE_LOGO_FIELD}[$node->language][0]['alt'])) {
      $vars['alt'] = t($node->{SUBSITE_LOGO_FIELD}[$node->language][0]['alt']);
    }

    // Title.
    if (isset($node->{SUBSITE_LOGO_FIELD}[$node->language][0]['title']) &&
      !empty($node->{SUBSITE_LOGO_FIELD}[$node->language][0]['title'])) {
      $vars['logo_title'] = t($node->{SUBSITE_LOGO_FIELD}[$node->language][0]['title']);
    }
  }

  // Setup subsite logo and title vars
  // ///////////////////////////////////////////////////////////////////////////

  // Handle the linkage to the subsite logo and title.
  if (isset($node->{SUBSITE_FRONT_PAGE_FIELD}[$node->language][0]["value"])) {

    // Support default themes
    // Change the front page variable to link to the subsite.
    if ($node->{SUBSITE_FRONT_PAGE_FIELD}[$node->language][0]["value"] == "subsite") {
      $vars['front_page'] = url('node/' . $node->nid, array('absolute' => TRUE));
    }

    // Support customized themes
    // Render the HTML for the logo.
    if ($vars['logo']) {
      $img = theme("image", array(
        'path' => $vars['logo'],
        'role' => 'presentation',
        'alt' => check_plain($vars['alt']),
        'title' => check_plain($vars['site_name']),
        'attributes' => array('class' => 'subsite-logo')
        )
      );
    }

    // Set the link setting as a variable for page.tpl.php
    $vars['subsite_name_logo_setting'] = $node->{SUBSITE_FRONT_PAGE_FIELD}[$node->language][0]["value"];

    // What the active subsite setting is.
    switch ($node->{SUBSITE_FRONT_PAGE_FIELD}[$node->language][0]["value"]) {

      // Link the logo and the title to the subsite.
      case "subsite":
        if ($vars['logo']) {
          $vars['subsite_logo'] = l($img, "node/" . $node->nid, array('html' => TRUE));
        }
        $vars['subsite_site_name_html'] = l($vars['site_name'], "node/" . $node->nid);

        // Set the variable as well for use in the theme.
        break;

      // Link the title to the subsite and the logo to the main site.
      case "split":
        if ($vars['logo']) {
          $vars['subsite_logo_html'] = l($img, "<front>", array('html' => TRUE));
        }
        $vars['subsite_site_name_html'] = l($vars['site_name'], "node/" . $node->nid);
        break;

      // Link both to main site.
      default:
        if ($vars['logo']) {
          $vars['subsite_logo_html'] = l($img, "<front>", array('html' => TRUE));
        }
        $vars['subsite_site_name_html'] = l($vars['site_name'], "<front>");
    }

  }

  // SUBSITE SLOGAN
  // ///////////////////////////////////////////////////////////////////////////

  if (isset($node->{SUBSITE_SLOGAN_FIELD}[$node->language][0]["value"])) {
    $vars['site_slogan'] = t($node->{SUBSITE_SLOGAN_FIELD}[$node->language][0]["value"]);
  }

  // FRONT Variables
  // ///////////////////////////////////////////////////////////////////////////

  // Set the url for use in the theme to the active subsite.
  $vars['subsite_front'] = url(
    'node/' . $node->nid,
    array('absolute' => TRUE)
  );

}

/**
 * Implements hook_node_submit().
 * @param $node: The node object being updated in response to a form submission.
 * @param $form: The form being used to edit the node.
 * @param $form_state: The form state array.
 *
 * Utiltity tasks for saving nodes of various types
 * 1. Clear path caches for subsites
 * 2. Check for missing subsite field on non subsite nodes
 */
function stanford_subsites_node_submit($node, $form, &$form_state) {

  // If we are saveing a subsite content type clear path cache
  // and perform subsite specific handling.
  if ($node->type == SUBSITE_CONTENT_TYPE) {
    // Clear all path caches.
    cache_clear_all('stanford_subsites_subsite_paths', 'cache', TRUE);
  }


  // If the user did not have access to the subsite selector then we need to add
  // the users subsite setting to the node.
  global $user;
  $account = user_load($user->uid);
  $values = &$form_state['values'];
  $language = $form['language']['#value'];

  // Check to see if the reference field is in the form and if it was submitted.
  if (isset($form[SUBSITE_REF_FIELD]) && !isset($values[SUBSITE_REF_FIELD])) {

    // Field exists on this form but was not submitted. User did not have access.
    if (isset($account->{SUBSITE_USER_REF_FIELD}[$language][0]['target_id']) &&
      is_numeric($account->{SUBSITE_USER_REF_FIELD}[$language][0]['target_id'])) {
      // User has a subsite setting.
      $ref_id = $account->{SUBSITE_USER_REF_FIELD}[$language][0]['target_id'];
      form_set_value($form[SUBSITE_REF_FIELD], $ref_id, $form_state);
      $node->{SUBSITE_REF_FIELD}[$language][0]['target_id'] = $ref_id;
    }

  }

  // Check to see if the submitted node has a subsite_tags field and a reference
  // the the subsite that is selected in the ref field.
  if (isset($form[SUBSITE_TAGS_FIELD])) {

    // Check to see that there is a subsite NID available.
    if (isset($values[SUBSITE_REF_FIELD])
      && is_numeric($values[SUBSITE_REF_FIELD][$language][0]['target_id'])) {

      $subsite_node = node_load($values[SUBSITE_REF_FIELD][$language][0]['target_id']);
      $subsite_term = _get_subsite_term($subsite_node);
      $found_term = FALSE; // Boolean switch for finding the term.

      if ($subsite_term) {
        // Check to see that tags field has reference.
        foreach ($values[SUBSITE_TAGS_FIELD][$language] as $k => $term) {
          if ($term['tid'] == $subsite_term->tid) {
            $found_term = TRUE;
            break;
          }
        }
      }
      else {
        // For some reason or another there is no subsite term. Create one.
        $subsite_term = _insert_subsite_term($subsite_node);
      }

      // Did not find the subsite term in the subsite tags field. Add it!
      if (!$found_term) {
        $tags = $values[SUBSITE_TAGS_FIELD][$language];
        $tags[] = (array) $subsite_term;
        form_set_value($form[SUBSITE_TAGS_FIELD], $tags, $form_state);
        $node->{SUBSITE_TAGS_FIELD}[$language] = $tags;
      }

    }

  }

}

/**
 * Handles the insert of a new subsite content type
 * @param  object $node       the node object
 *
 * Tasks:
 * 1. Create subsite term
 * 2. Check for subsite ref in order to set active workspace
 */
function stanford_subsites_node_insert($node) {

  // We have a new subsite content type. Lets add it to the subsite vocabulary.
  if ($node->type == SUBSITE_CONTENT_TYPE) {
    _insert_subsite_term($node);

    // Storage for passing arguments to subsequential functions.
    $args = array();

    // If menu/menublock creation is enabled do it!
    if (variable_get("stanford_subsite_enabled_menus", FALSE)) {
      $args += _create_subsite_menu_and_menublock($node);
      _enable_menu_for_subsite_content_types($args['menu']);
    }

    // Create a subsite context for this subsite.
    _create_subsite_context($node, $args);

  }

  // Set the cookie for active subite working space if subsite ref was provided.
  if (isset($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']) &&
    is_numeric($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id'])) {
    _set_subsite_workingspace($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']);
  }
  else {
    _clear_subsite_workingspace();
  }

}


/**
 * Implements hook_node_update().
 * 1. Clears the path cache for subsite nodes
 * 2. Checks for subsite ref field in order to set the active subsite workspace
 */
function stanford_subsites_node_update($node) {

  // Clear out all of the subsite paths so they get updated.
  if ($node->type == SUBSITE_CONTENT_TYPE) {
    // Clear all path caches.
    cache_clear_all('stanford_subsites_subsite_paths', 'cache', TRUE);
    _update_subsite_node_term_name($node);
  }

  // Set the cookie for active subite working space if subsite ref was provided.
  if (isset($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']) &&
    is_numeric($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id'])) {
    _set_subsite_workingspace($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']);
  }
  else {
    _clear_subsite_workingspace();
  }


}


/**
 * Implements pathauto_alias_alter()
 * Prepends the pathalias of the subsite to a node being referenced to one
 */
function stanford_subsites_pathauto_alias_alter(&$alias, $context) {
  $node = (isset($context['data']['node'])) ? $context['data']['node'] : FALSE;
  $original_alias = $alias;

  // A taxonomy term or a user.
  if (!$node) {
    return;
  }

  // If there is a reference to a subsite then alter the pathauto_alias
  if (isset($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']) &&
  is_numeric($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id'])) {
    $subsite_node = node_load($node->{SUBSITE_REF_FIELD}[$node->language][0]['target_id']);
    $alias = drupal_get_path_alias("node/" . $subsite_node->nid) . "/" . $original_alias;
  }

}

/**
 * Implements hook_form_alter().
 * Add the active theme options to the theme field
 */
function stanford_subsites_form_node_form_alter(&$form, &$form_state, $form_id) {

  // ---------------------------------------------------------------------------
  // ONLY Subsite content types
  // ---------------------------------------------------------------------------

  if ($form_id == SUBSITE_CONTENT_TYPE . "_node_form") {
    stanford_subsites_form_node_form_alter_subsite_node($form, $form_state, $form_id);
    return;
  }

  // ---------------------------------------------------------------------------
  // The rest of the node forms..
  // ---------------------------------------------------------------------------

  if ($form['#node_edit_form']) {

    $language = $form['language']['#value'];
    // Global user object.
    global $user;
    $account = user_load($user->uid);

    // Check for site theme field.
    if (isset($form[SUBSITE_REF_FIELD])) {

      // If default subsite is not selected and this is the node create form
      // then set to users current workspace
      // or default account setting.

      if (empty($form[SUBSITE_REF_FIELD][$language]['#default_value'][0]) ||
        !is_numeric($form[SUBSITE_REF_FIELD][$language]['#default_value'][0])) {

        if (isset($form['nid']['#value'])) {
          // Node exists already. Carry on.
        }
        // Check to see if the user has an active working space for the default.
        elseif ($niid = _get_subsite_workingspace()) {
          $form[SUBSITE_REF_FIELD][$language]['#default_value'][0] = $niid;
        }
        // Check to see if the user has a subsite account setting.
        elseif (isset($account->{SUBSITE_USER_REF_FIELD}[$language][0]['target_id']) &&
          is_numeric($account->{SUBSITE_USER_REF_FIELD}[$language][0]['target_id'])) {
          $form[SUBSITE_REF_FIELD][$language]['#default_value'][0] = $account->{SUBSITE_USER_REF_FIELD}[$language][0]['target_id'];
        }

      }

      $subsite_nodes = node_load_multiple(array_keys($form[SUBSITE_REF_FIELD][$language]['#options']));
      // Fix the rendering of the options as they dont handle html entities right.
      foreach ($subsite_nodes as $k => $snode) {
        $form[SUBSITE_REF_FIELD][$language]["#options"][$snode->nid] = decode_entities($snode->{SUBSITE_NAME_FIELD}[$language][0]['value']);

      }
    }
  }
}

/**
  * Implements hook_form_FORM_ID_alter().
  */
function stanford_subsites_user_settings_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  $description = '<p>' . t('Choose the subsite(s) to associate with your account. The first listed subsite will be your default when creating new nodes.') . '</p>';
  $form['field_stanford_subsite_usr_sub'][LANGUAGE_NONE]['#description'] = $description;

  // Update the labels :)
  foreach ($form['field_stanford_subsite_usr_sub'][LANGUAGE_NONE] as $k => $value) {

    // Check for empty field.. @todo: clean this check up.
    if (!is_array($value) ||
     !isset($value['target_id']) ||
     !is_object($value['target_id']['#entity']) ||
     !isset($value['target_id']['#entity']->{SUBSITE_USER_REF_FIELD}[LANGUAGE_NONE][$k])
     ) {
      continue;
    }

    // Load up the node from cache.
    $node = node_load($value['target_id']['#entity']->{SUBSITE_USER_REF_FIELD}[LANGUAGE_NONE][$k]['target_id']);

    // If node was deleted or something skip.
    if (!$node) {
      continue;
    }

    // Get and set the new site name.
    $site_name = $node->{SUBSITE_NAME_FIELD}[LANGUAGE_NONE][0]['value'];
    $form['field_stanford_subsite_usr_sub'][LANGUAGE_NONE][$k]['target_id']["#default_value"] = $site_name . " (" . $node->nid . ")";
  }

}


/**
 * stanford_subsites_form_node_form_alter_subsite_node()
 * @param   $form the form array
 * @param   $form_state the submitted form state
 * @param   $form_id the form idate(format)
 */
function stanford_subsites_form_node_form_alter_subsite_node(&$form, &$form_state, $form_id) {
  $node = $form['#node'];

  // Add only enabled themes to the theme drop down options...
  $themes = list_themes();
  foreach ($themes as $k => $theme) {
    if (!$theme->status) {
      continue;
    }
    $form[SUBSITE_THEME_FIELD][$node->language]['#options'][$k] = $k;
  }

  // Set the default value.
  $form[SUBSITE_THEME_FIELD][$node->language]['#default_value'] =
    (isset($node->{SUBSITE_THEME_FIELD}[$node->language][0]['value']))
    ? $node->{SUBSITE_THEME_FIELD}[$node->language][0]['value']
    : "default";

  // Add a link to enable more themes below the field.
  $form[SUBSITE_THEME_FIELD][$node->language]["#description"] = l(t('Enable more themes here'), "admin/appearance");

}

//  ////////////////////////////////////////////////////////////////////////////
//  FEILDS + Autocomplete //
//  ////////////////////////////////////////////////////////////////////////////

/**
 * Implements hook_field_access().
 */
function stanford_subsites_field_access($op, $field, $entity_type, $entity, $account) {

  // Check to see if user can edit the subsite selection field.
  if ($field['field_name'] == SUBSITE_REF_FIELD && $op == 'edit') {
    return user_access('administer subsite selection', $account);
  }

  return TRUE;
}

/**
 * Menu callback: autocomplete the label of an entity.
 *
 * @param $type
 *   The widget type (i.e. 'single' or 'tags').
 * @param $field_name
 *   The name of the entity-reference field.
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name.
 * @param $entity_id
 *   Optional; The entity ID the entity-reference field is attached to.
 *   Defaults to ''.
 * @param $string
 *   The label of the entity to query by.
 */
function stanford_subsites_entityreference_autocomplete_callback($type, $field_name, $entity_type, $bundle_name, $entity_id = '', $string = '') {
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  return stanford_subsites_entityreference_autocomplete_callback_get_matches($type, $field, $instance, $entity_type, $entity_id, $string);
}


/**
 * Return JSON based on given field, instance and string.
 *
 * This function can be used by other modules that wish to pass a mocked
 * definition of the field on instance.
 *
 * @param $type
 *   The widget type (i.e. 'single' or 'tags').
 * @param $field
 *   The field array defintion.
 * @param $instance
 *   The instance array defintion.
 * @param $entity_type
 *   The entity type.
 * @param $entity_id
 *   Optional; The entity ID the entity-reference field is attached to.
 *   Defaults to ''.
 * @param $string
 *   The label of the entity to query by.
 */
function stanford_subsites_entityreference_autocomplete_callback_get_matches($type, $field, $instance, $entity_type, $entity_id = '', $string = '') {
  $matches = array();

  $entity = NULL;
  if ($entity_id !== 'NULL') {
    $entity = entity_load_single($entity_type, $entity_id);
    if (!$entity || !entity_access('view', $entity_type, $entity)) {
      return MENU_ACCESS_DENIED;
    }
  }

  $handler = entityreference_get_selection_handler($field, $instance, $entity_type, $entity);

  if ($type == 'tags') {
    // The user enters a comma-separated list of tags. We only autocomplete the last tag.
    $tags_typed = drupal_explode_tags($string);
    $tag_last = drupal_strtolower(array_pop($tags_typed));
    if (!empty($tag_last)) {
      $prefix = count($tags_typed) ? implode(', ', $tags_typed) . ', ' : '';
    }
  }
  else {
    // The user enters a single tag.
    $prefix = '';
    $tag_last = $string;
  }

  if (isset($tag_last)) {
    // Get an array of matching entities.
    $entity_labels = $handler->getReferencableEntities($tag_last, $instance['widget']['settings']['match_operator'], 10);

    // Loop through the products and convert them into autocomplete output.
    foreach ($entity_labels as $values) {
      foreach ($values as $entity_id => $label) {
        $key = "$label ($entity_id)";
        // Strip things like starting/trailing white spaces, line breaks and tags.
        $key = preg_replace('/\s\s+/', ' ', str_replace("\n", '', trim(decode_entities(strip_tags($key)))));
        // Names containing commas or quotes must be wrapped in quotes.
        if (strpos($key, ',') !== FALSE || strpos($key, '"') !== FALSE) {
          $key = '"' . str_replace('"', '""', $key) . '"';
        }
        $matches[$prefix . $key] = '<div class="reference-autocomplete">' . $label . '</div>';
      }
    }
  }

  // Implment a hook to futz with autocomplete results :)
  foreach (module_implements('entityreference_alter_results') as $module) {
    $function = $module . '_entityreference_alter_results';
    $function($matches, $field, $instance, $entity_type, $entity_id, $string);
  }

  drupal_json_output($matches);
}


/**
 * Implements a hook alter for augmenting the entityreference autocomplete call
 * @param  $matches
 *   The matches already found by autocomplete. Just before it is sent to json.
 * @param $type
 *   The widget type (i.e. 'single' or 'tags').
 * @param $field
 *   The field array defintion.
 * @param $instance
 *   The instance array defintion.
 * @param $entity_type
 *   The entity type.
 * @param $entity_id
 *   Optional; The entity ID the entity-reference field is attached to.
 *   Defaults to ''.
 * @param $string
 *   The label of the entity to query by.
 */
function stanford_subsites_entityreference_alter_results(&$matches, $field, $instance, $entity_type, $entity_id = '', $string = '') {
  // Override the labels if the ref field is the subsite ref fields.
  if ($field['field_name'] == SUBSITE_REF_FIELD ||
    $field['field_name'] == SUBSITE_USER_REF_FIELD) {

    // Add additional Matches Here and overwrite keys with new matches and label.
    $my_query = db_select("field_data_" . SUBSITE_NAME_FIELD, 'sf')
              ->fields('sf', array(SUBSITE_NAME_FIELD . '_value', 'entity_id'))
              ->condition(SUBSITE_NAME_FIELD . '_value', "%" . $string . "%", 'LIKE')
              ->range(0, 10)
              ->execute();

    while ($o = $my_query->fetchAssoc()) {
      // Its cached :).
      $node = node_load($o['entity_id']);
      // Remove old match.
      unset($matches[$node->title . " (" . $node->nid . ")"]);
      $site_name = $node->{SUBSITE_NAME_FIELD}[$node->language][0]['value'];
      $matches[$site_name . " (" . $node->nid . ")"] = '<div class="reference-autocomplete">' . $site_name . '</div>';
    }
  }

}

/**
 * Override the output of the reference field by default so that it does
 * site_name instead of $title
 *
 */
function stanford_subsites_preprocess_field(&$vars, $hook) {
  $field = &$vars['element'];
  if (isset($field['#field_name']) && $field['#field_name'] == SUBSITE_USER_REF_FIELD) {
    foreach ($field['#items'] as $k => $v) {
      $site_name = $v['entity']->field_stanford_subsite_sname[$v['entity']->language][0]['safe_value'];
      $field[$k]['#markup'] = $site_name;
      $vars['items'][$k]["#markup"] = $site_name;
    }
  }

}


/**
 * Schtoopid views messing with my preprocessed output...
 * Alter the output of the user_sub_target_id autocomplete field on all views
 */

function stanford_subsites_preprocess_views_view_field(&$vars) {

  $field = $vars['field'];
  if ($field->real_field == "field_stanford_subsite_usr_sub_target_id") {
    // Fix the field output.

    $row = &$vars['row'];
    $items = array();
    foreach ($row->field_field_stanford_subsite_usr_sub as $k => $v) {
      $raw = $v['raw'];
      $site_name = $raw['entity']->{SUBSITE_NAME_FIELD}[$raw['entity']->language][0]['safe_value'];

      // Add to items.
      $items[] = l($site_name, 'node/' . $raw['entity']->nid);
    }

    $vars['output'] = theme_item_list(array(
      'items' => $items,
      'title' => '',
      'type' => 'ul',
      'attributes' => array()
      )
    );
  }

}

//  ////////////////////////////////////////////////////////////////////////////
//  TOKENS //
//  ////////////////////////////////////////////////////////////////////////////

/**
 * Implements hook_token_info().
 */
function stanford_subsites_token_info() {

  // Active subsite specific tokens.
  $types['stanford_subsites'] = array(
    'name' => t("Stanford Subsites"),
    'description' => t("The Stanford Subsite Project."),
  );

  // Active subsite page title $node->title
  $stanford_subsites['active_subsite_page_title'] = array(
    'name' => t("Active Subsite Page Title"),
    'description' => t("The Active Subsite Page Title"),
  );

  // Active subsite site name $node->field_stanford_subsite_site_name
  $stanford_subsites['active_subsite_site_name'] = array(
    'name' => t("The Active Subsite Site Name"),
    'description' => t("The site name of the active subsite."),
  );

  // The absolute url path to the active subsite.
  $stanford_subsites['active_subsite_url'] = array(
    'name' => t("The Active Subsite Url Path"),
    'description' => t("The url path to the active subsite."),
  );

  // The node id of the active subsite. $node->nid
  $stanford_subsites['active_subsite_node_id'] = array(
    'name' => t("The Active Subsite Node ID"),
    'description' => t("The node ID of the active subsite."),
  );

  return array(
    'types' => $types,
    'tokens' => array(
      'stanford_subsites' => $stanford_subsites,
    ),
  );
}


/**
 * Implements hook_tokens().
 */
function stanford_subsites_tokens_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $subsite = _get_active_subsite();

  // If there is no active subsite do not return anything.
  if (!$subsite) {
    return array();
  }

  $replacements = array();

  if ($type == 'stanford_subsites') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'active_subsite_page_title':
          $replacements[$original] = t($subsite->title);
          break;

        case 'active_subsite_site_name':
          $replacements[$original] = t($subsite->{SUBSITE_NAME_FIELD}[$subsite->language][0]['safe_value']);
          break;

        case 'active_subsite_url':
          $replacements[$original] = url('node/' . $subsite->nid, array('absolute' => TRUE));
          break;

        case 'active_subsite_node_id':
          $replacements[$original] = $subsite->nid;
          break;
      }
    }
  }

  return $replacements;
}


//  ////////////////////////////////////////////////////////////////////////////
//  VIEWS PLUGINS and OTHER //
//  ////////////////////////////////////////////////////////////////////////////

/**
 * Implments hook_views_api
 * @return array
 */
function stanford_subsites_views_api() {
  return array("version" => "3.0");
}

// More in views.inc



//  ////////////////////////////////////////////////////////////////////////////
//  CONTEXT PLUGINS //
//  ////////////////////////////////////////////////////////////////////////////

/**
 * Implement `hook_context_plugins()` to define your plugins, classes, and class
 * hierarchy.
 * @return $plugins
 */
function stanford_subsites_context_plugins() {
  $plugins = array();
  $plugins['context_condition_active_subsite'] = array(
    'handler' => array(
      'path' => drupal_get_path('module', 'stanford_subsites') . '/plugins',
      'file' => 'context_condition_active_subsite.inc',
      'class' => 'context_condition_active_subsite',
      'parent' => 'context_condition',
    ),
  );
  return $plugins;
}

/**
 * Implement `hook_context_registry()` to define your conditions and/or
 * reactions and map them to plugins.
 * @return array
 */
function stanford_subsites_context_registry() {
  return array(
    'conditions' => array(
      'active_subsite' => array(
        'title' => t('Active Subsite'),
        'plugin' => 'context_condition_active_subsite',
      ),
    ),
  );
}

/**
 * Execute Context active subsite conditions
 *
 * Allows modules to hook into Context's hook_page_build to execute their
 * conditions at an appropriate time before the firing of reactions.
 */
function stanford_subsites_context_page_condition() {

  $plugin = context_get_plugin('condition', 'active_subsite');
  if ($plugin) {
    $plugin->execute();
  }

}


